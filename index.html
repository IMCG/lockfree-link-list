<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    
    <script type="text/javascript" src="javascripts/jquery-2.1.1.min.js"></script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Unlocking Potential by Dave Cummings and Stephen Bly</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Unlocking Potential</h1>
        <h2>An Eye-Opening Exploration of Non-Blocking Linked Lists</h2>
        <a href="https://github.com/davidhcummings/lockfree" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <div id="blurb">
            <p>A project by <a href="http://github.com/davidhcummings">Dave Cummings</a> and <a href="http://github.com/sbly">Stephen Bly</a>, and a finalist in CMU's Spring 2014 Parallelism Competition. Check out the other <a href="http://15418.courses.cs.cmu.edu/spring2014/competition">awesome submissions</a>!</p>
          </div>
          <h2> It's a race! </h2>
          <div class="section">
	          <p>When multiple threads are making concurrent modifications to a shared data structure, a typical strategy is to use a lock so that only one thread can modify the structure at a time. We’re exploring alternative thread-safe schemes: <b>fine-grained locks</b>, which lock only the most necessary parts of the structure; and <b>atomic memory operations</b>, which allow us to forego locks altogether. Though each of these approaches has its appeals and its drawbacks, <b>we have found lock-free structures to be sensationally faster under conditions of high contention.</b> And perhaps even more important than speed, <b>we’ve discovered lock-free structures to be more energy-efficient than their counterparts.</b></p>
          </div>
          <h2>Background</h2>
          <div class="section">
      			<p>The most fundamental element to prevent concurrent threads operating on the same memory from scrambling one another's data is to use a lock. The status of the lock gets checked and then modified whenever a thread wants to access or change the protected data, and then unlocked upon completion. The terms "coarse-grained" and "fine-grained" refer to general strategies of using locks: whether to have very few locks limiting access to large portions of memory or to have many locks that each limit access to a small portion of memory.</p>
      			<p>We began our investigation of lock-free linked lists by reading the papers recommended in the class slides on lock-free data structures. We read papers by <a href="http://www.research.ibm.com/people/m/michael/podc-1996.pdf">Michael</a>, <a href="http://www.cs.bgu.ac.il/~mpam092/wiki.files/lock-free-linked-list.pdf">Fomitchev and Ruppert</a>, and <a href="http://research.microsoft.com/pubs/67089/2001-disc.pdf">Harris</a>. We got our idea for looking at energy usage from <a href="http://www.cs.fsu.edu/~xyuan/INTERACT-15/papers/paper06.pdf">Hunt, Sandhu, and Ceze</a>.</p>
      			<p>Reading these papers showed us just how difficult lock-free linked lists are to implement correctly. Many of them even had errors in their implementation that were pointed out only after the paper had been published. After reading all of them, we decided on implementing the linked-list described in Harris. It was easy enough to understand (though still considerably more complex than its lock-based counterparts), and boasted significant performance improvements.</p>          </div>
          <h2>Methodology</h2>
          <div class="section">
            <p>In comparing the performance of different thread-safe list implementations, it was important to us that using the lists was practical from the perspective of an engineer and not just from an efficiency standpoint. It was important to us that the lists inherit from a common interface that declared what operations could be performed, and that developers (ourselves included) could call the same function on any list implementation and expect the same result. It was also important that the lists support generics, without which our lists have basically no real-world utility.</p>
<pre>
  <code>...</code>
  
  vector&lt;List&lt;elem_t&gt;*&gt; lists;
  lists.push_back(<span class="code-key">new</span> CoarseGrainedList&lt;elem_t&gt;());
  lists.push_back(<span class="code-key">new</span> FineGrainedList&lt;elem_t&gt;());
  lists.push_back(<span class="code-key">new</span> LockFreeList&lt;elem_t&gt;());
  
  <span class="code-key">bool</span> isSane = <span class="code-key">true</span>;
  for (<span class="code-key">unsigned int</span> i = <span class="code-val">0</span>; i &lt; lists.size(); i++) {
      isSane &amp;= test_sanity(*lists[i]);
  }
  <span class="code-key">if</span> (isSane) {
      cout &lt;&lt; <span class="code-str">"Sanity tests passed!"</span>;
  } <span class="code-key">else</span> {
      cout &lt;&lt; <span class="code-str">"Sanity tests failed! #define DEBUGGING to run in debug mode."</span>;
  }
  
  <code>...</code>
  
}
  
<span class="code-key">bool</span> test_sanity(List&lt;elem_t&gt;&amp; list)
{

  <code>...</code>
  
}
            </pre>
            <p></p>
	          <h3>Testing</h3>
	          <div class="subsection">
		          <p>We designed tests specifically to test extreme situations and exaggerate the advantages and disadvantages of each list implementation. The final test suite breaks down into three categories:</p>
		            <h4>Sanity tests</h4>
		            <p class="subsubsection">The quickest to run and the first to fail in the event of a glaring implementation mistake. Sanity tests were particularly helpful as we gained familiarity with inheritance and polymorphism in C++. By having all the thread-safe list implementations inherit from the same "interface" we could simply maintain a collection of lists and pass them to the same test functions. In addition to cleanliness and adhering to good software engineering practices, this meant that any change to a test was automatically reflected for each of the list implementations with which it was run.</p>
		            <h4>Size tests</h4>
		            <p class="subsubsection">Helped confirm the list invariants were maintained. Size tests make only insertions, no deletions, so list accesses become slower, and we expected lists with high per-node logic (*ahem* FineGrained) and coarse mutual exclusion to really take a beating in these tests. Size tests push these lists to the limits of their practicality and give us an opportunity to measure what those limits are.</p>
		            <h4>Jam tests</h4>
		            <p class="subsubsection">The opposite of size tests, jam tests perform millions of insertions and deletions without the list exceeding a small size. For each insertion performed, the test suite makes a removal immediately afterward. We designed jam tests to measure how well the implementations perform under pressure, when the number of concurrent operations attempted at any given moment may even exceed the number of elements in the list. Jam tests also help verify correctness; they can't tell us where our code might have gone wrong, but they can tell us to focus on the interplay between <code>insert</code> and <code>remove</code>.</p>
	            </div>
	          <h3>Environments</h3>
	          <div class="subsection">
	            <p>Our primary test machine was a mid-2013 MacBook Air ("<a href="http://www.everymac.com/systems/apple/macbook-air/specs/macbook-air-core-i7-1.7-11-mid-2013-specs.html">MacBookAir6,1</a>") equipped with a dual-core <a href="http://ark.intel.com/products/75114/Intel-Core-i7-4650U-Processor-4M-Cache-up-to-3_30-GHz">i7-4650U</a>. We also ran tests on remote machines, specifically a workstation equipped with a 6-core <a href="http://ark.intel.com/products/47918/Intel-Xeon-Processor-W3670-12M-Cache-3_20-GHz-4_80-GTs-Intel-QPI">Xeon W3670</a> and a 32-CPU instance on Pittsburgh Supercomputing Center's <a href="http://www.psc.edu/index.php/computing-resources/blacklight">Blacklight</a>. We later allude to results from these tests, but over the course of the project we found ourselves less and less reliant on remote machines and more immersed in tests run on the Mac. The big advantage was being able to deploy instantly, not having to wait in a queue to run the compiled code, and not having to share precious CPU resources with the rest of the School of Computer Science. As we progressed, our software became more specialized for OS X, and so running new tests on these remote machines became impossible.</p>
	          </div>
	          <h3>Monitoring</h3>
	          <div class="subsection">
		          <p>For monitoring elapsed time, we used <a href="https://github.com/davidhcummings/lockfree/blob/master/tst/cycle_timer.h">CycleTimer</a>, which was provided by the 418 course staff for multiple assignments. CycleTimer directly counts the number of number of CPU ticks to get as granular reporting of time as possible. CycleTimer executes unique logic for each system. For example, for x86-64, CycleTimer makes an inline assembly call to read the <a href="http://en.wikipedia.org/wiki/Time_Stamp_Counter"><code>tsc</code> register</a>.</p>
		          <img src="images/istat.png" align="right">
		          <p>To monitor power, we had to develop our own tools. The result is not only specific to OS X but actually exclusive to MacBook Airs (MacBooks Air?) shipped since June 2013.</p>
		          <p>Every Intel-based Mac uses <a href="http://en.wikipedia.org/wiki/System_Management_Controller">System Management Controller</a> to manage auxiliary internal hardware components, primarily to adjust fan speeds in reaction to changes in intnernal temperature. Because the operating system is dependent on certain bits of information maintained by SMC (like knowing to shut down if the CPU overheats) the subsystem can be queried by the kernel using <a href="https://developer.apple.com/library/mac/documentation/devicedrivers/conceptual/IOKitFundamentals/Introduction/Introduction.html">IOKit</a>, Apple's API for writing device drivers. Apple has absolutely zero documentation about interfacing with SMC, and with good reason: you can set values just as easily as you can query them, so in theory you could, say, up the voltage on your CPU and completely fry the system.</p>
		          <p>A developer known only as <em>devnull</em> created an interface for making read-only calls to SMC, and we've <a href="https://github.com/davidhcummings/lockfree/blob/master/tst/smc.cpp">modified it</a> to query the power sensors on a MacBookAir6,1. Every model of Mac has a different assortment of sensors and (perhaps to add security through obscurity) each sensor is identified by a four-character key that's unique to each model. The mappings from keys to sensors aren't published anywhere; developers have had to feel around to find them and new keys are still being discovered. The folks at <a href="http://bjango.com">Bjango</a> developed <a href="http://bjango.com/mac/istatmenus/">iStat Menus</a> (pictured right) and hard-coded known SMC keys. By decompiling the app, we were able to extract the keys corresponding to power sensors for our MacBook Air test machine. Some further digging into the decompiled source revealed that the recent MacBook Air is the only Mac for which the keys are known for the power sensors on the SSD and DRAM. (The SMC keys for the CPU power sensor are known for most recent Macs.)</p>
<pre>function +[MacBookAir6_1 supportedSensors] {
  var_64 = [[NSMutableArray alloc] init];
  xmm0 = intrinsic_xorps(xmm0, xmm0, *objc_cls_ref_NSNumber, *0x1001bac48);
  r12 = [__got__objc_msgSend() retain];
  xmm0 = intrinsic_movsd(xmm0, *0x100133070, *objc_cls_ref_NSNumber, *0x1001bac48);
  r13 = [__got__objc_msgSend() retain];
  rbx = [var_64 dictionaryWithObjectsAndKeys:<span class="code-str">@"PSDC"</span>, <span class="code-str">@"key"</span>, <span class="code-str">@"SSD"</span>, <span class="code-str">@"name"</span>];</pre>
	            <p>We packaged functions for getting system time and power usage statistics into a singleton class called <a href="https://github.com/davidhcummings/lockfree/blob/master/tst/monitor.cpp">Monitor</a>. When running with the monitor, a few things are different from our standard test suite. First, we use pthreads instead of OpenMP, since Clang does not natively support OpenMP. We divide a test's input array into evenly-sized contiguous chunks, which closer resembles OpenMP <code>static</code> scheduling rather than the default <code>dynamic</code>. Additionally, the act of observing can interfere with the tests themselves, since the monitoring tasks run in a thread that runs alongside the worker threads. We found evidence of this interference, since on average every single test ran slower with power monitoring off than with it on; however, the difference in speed was typically less than 1% and execution time was always within the standard deviation of the length of corresponding unmonitored tests.</p>
	            <p>An important caveat: since Apple offers no documentation on SMC, we don't have a reputable source promising validity of what it reports. We found that when the CPU is running at peak, the reading from the power sensor reported seems to change only once every 1.38 seconds, even though the monitoring thread can poll the SMC at a granularity as fine as 16 milliseconds. At peak, these changes are slight, often by fractions of watts. It could well be that inside that 1.38-second interval SMC will only adjust voltage and current when the workload changes drastically, and we have some data to suggest SMC might have a much faster reaction time: when we inserted the occasional <code>nanosleep</code> into our code, we sometimes saw changes in wattage as frequent as the SMC was polled. And while the SMC could be continuously adjusting wattage and only reporting the change every 1.38 seconds, it's also possible that during peak, when workloads stay consistent, the SMC keeps the CPU power at about the same level.</p>
            </div>
          </div>
          <h2>Results</h2>
          <div class="section">
            <p>Lock-free linked lists ("LockFree") outperformed its rivals in almost every single iteration of every single test, often by a wide margin. Perhaps more interesting than the times it outperformed are those when it underperformed. The graph below shows just how big LockFree's margin of victory is.</p>
            <img src="images/charts/1.png">
            <p>In this jam test with a fixed list size of 16 on 10,000,000 insertion/deletion iterations, LockFree performs astoundingly better in a multithreaded context. It even performs better in the single-threaded context, but the difference is not as exaggerated. Even more impressive than the absolute speed differences is how well LockFree scales when running 128 parallel threads on a dual-core CPU; the blue line stays practically flat. We attribute this to the impressive speediness of the atomic <code>__sync_bool_compare_and_swap</code>, which keeps overhead low during traversal and swaps.</p>
            <img src="images/charts/2.png">
            <p>In this size test on 100,000 iterations, we see one of the few instances in which LockFree actually does worse than one of its rivals. LockFree's traversal and read/write logic is actually slightly more expensive per thread than CoarsGrained's simple lock-once-and-iterate. FineGrained appears to scale well compared to its single-threaded execution but still lags behind its rivals.</p>
            <img src="images/charts/3.png">
            <p>Not only does LockFree execute way, way faster, it consumes even less electricity, as shown in the graph above…</p>
            <img src="images/charts/4.png">
            <p>…however, if we look at performance-per-watt, as shown on this adjusted index, we see that since all implementations basically use 100% of the CPU, consumption is primarily just a function of execution time.</p>
          </div>
          <h3>Future Work</h3>
          <div class="section">
            <h4>Hashtables</h4>
            <div class="subsection">
              <p>We wanted to further improve the usefulness of our key-value lists. To this end, we decided on trying to implement a hashtable (also supporting generic types and hash functions), which is a pivotal computer science data structure that supports much faster operations than linked lists. We spent a good deal of time working on using our lock-free lists to implement lock- free hashtables. In particular, we would use the lock-free lists to chain elements that collided in the table. Buckets in the hashtable were already independent and needed no synchronization.</p>
              <p>While we wrote an almost-complete hashtable implementation, we were unable to test our code because of compiler and linker errors that neither of us could figure out (or even understand) after a day of debugging. Due to time constraints, we ultimately decided to focus on other things that we could make tangible progress on. However, we still feel that lock-free hashtables have the potential to be extremely useful to multi-threaded applications and will one day be in wide-spread use.</p>
            </div>
            <h4>Sets</h4>
            <div class="subsection">
              <p>Most implementations of sets, which support operations like <code>union</code> and <code>intersect</code>, are implemented using sorted linked lists because of their built in filtering of duplicates and the ability perform many set operations inexpensively. These operations also have the potential to be highly parallelized (if you had infinite execution contexts you could, say, assign each one a value from set A to find in set B, and thus achieve constant span.) This would have been another interesting application to explore, and one that is highly practical.</p>
            </div>
          </div>
          <h2>References</h2>
          <div class="section">
            <ul>
              <li>Kayvon Fatahalian: <a href="http://15418.courses.cs.cmu.edu/spring2014/lecture/lockfree"><em>Fine-Grained Sync and Lock-Free Structures</em></a>. 2014 (Carnegie Mellon University)</li><br>
              <li>Nicholas Hunt, Paramjit Singh Sandhu, Luis Ceze: <a href="http://www.cs.fsu.edu/~xyuan/INTERACT-15/papers/paper06.pdf"><em>Characterizing the Performance and Energy Efficiency of Lock-Free Data Structures</em></a>. 2012 (University of Washington)</li><br>
              <li>Scott Michael: <a href="http://www.research.ibm.com/people/m/michael/podc-1996.pdf"><em>Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms</em></a>. 1996 (University of Rochester)</li><br>
              <li>Mikhail Fomitchev, Eric Ruppert: <a href="http://www.cs.bgu.ac.il/~mpam092/wiki.files/lock-free-linked-list.pdf"><em>Lock-Free Linked Lists and Skip Lists</em></a>. 2004 (York University)</li><br>
              <li>Timothy Harris: <a href="http://research.microsoft.com/pubs/67089/2001-disc.pdf"><em>A Pragmatic Implementation of Non-Blocking Linked Lists</em></a>. 2001 (University of Cambridge)</li>
            </ul>
            <p>Our proposal is available <a href="proposal.html">here</a>.</p>
          </div>
          <h3>Acknowledgements</h3>
          <div class="section">
            <p>Equal work was performed by both project members.</p>
            <p>Huge thanks to Kayvon Fatahalian for guidance and support. Thanks also to Robert Esser and Duane Merrill for feedback and suggestions for future work.</p>
          </div>
        </section>

        <aside id="sidebar">
          <div id="contentsDiv">
            <ul id="contentsUL">
            </ul>
          </div>

          <p id="credit">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

    <script type="text/javascript" src="javascripts/main.js"></script>
  </body>
</html>